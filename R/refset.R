
# TODO/IDEAS:

"
Allow reference() to do assignment if you pass read.only=FALSE? E.g. by
adding some code in to call do.call('<-', list(reference, x))?

class refset and reference (optionally?) and override names()<-? and similar...
override <-
"

# would like this to work but it doesn't at the mo:
# dfr <- data.frame(a=1:2, b=1:2)
# refset(rs, dfr,)
# names(rs) <- c("c", "d")
# similarly with rownames() etc...
#
# Observe:
# > dfr <- data.frame(a=3:4, b=5:6)
# > refset(rs, dfr,,)
#   a b
# 1 3 5
# 2 4 6
# > `length<-`(rs, 1)
# $a
# [1] 3 4
# 
# > rs
#   a b
# 1 3 5
# 2 4 6
# > length(rs) <- 1
# > rs
#   a b
# 1 3 3
# 2 4 4
#
# why this happens:
# the call evaluates to `length<-`(rs, 1)
# this returns a 1-length version of dfr, i.e. just dfr$a
# the result is automatically assigned to rs
# but we haven't really changed the length of dfr
# so we get the repetition
# if you do e.g. names(x)[1] <- "jim"
# then names(x) is called, the first component is replaced by "jim"
# and the result is passed to `names<-` ... then the result is assigned to 
# x.

#' Create a reference to a subset of an object
#' 
#' Create a refset - a reference to a subset of an object. 
#' When the object changes, the
#' contents of the refset change, and when the refset is changed, the object
#' is changed too.
#' 
#' @param x name of the refset to create, as a bare name or character string
#' @param data the object to refer to
#' @param ... indices to subset with
#' @param drop passed to \code{\link{Extract}}
#' @param dyn.idx update indices dynamically
#' @param read.only create a read-only refset which throws an error if assigned
#'        to
#' @param eval.env environment in which \code{data} and indices will be evaluated
#' @param assign.env environment in which the variable named by \code{x} will be created 
#' 
#' @details
#' There are two ways to call \code{refset}. The two-argument form, e.g.
#' \code{refset(myref, mydata[rows,"column"])}, creates a reference to the 
#' subset of \code{mydata} passed in the second argument. The three-or-more
#'argument form acts like the \code{\link{subset}} function: the indices in 
#' \code{...} are applied to \code{data}. If \code{data} is a data.frame, then
#' \code{...} is interpreted within it, so you can refer to columns directly: 
#' \code{refset(myref, mydata, a>1 & b<a,)}. Bare column names must be quoted,
#' however.
#' 
#' Empty arguments in \code{...} are allowed and are treated as indexing 
#' the whole dimension, just as in \code{\link{Extract}}.
#' 
#' By default, the indices in subset are updated dynamically. 
#' For example, if you call \code{refset(myref, mydata, x >= 3,)} and then
#' set \code{mydata$x <- 3}, the number of rows in \code{myref} will
#' increase. To turn this behaviour off and make a reference to a "fixed" 
#' subset of your object, use \code{dyn.idx=FALSE}.
#' 
#' 
#' @return \code{refset} returns \code{NULL}, but the \code{x} argument 
#' will be assigned to
#' in the calling environment (or in \code{env}, if it is specified). 
#' \code{x} will have an attribute \code{".refset."}.
#' \code{is.refset} returns \code{TRUE} or \code{FALSE}.
#' 
#' @seealso
#' Refsets are implemented using \code{makeActiveBinding}.
#' 
#' @family parcel
#' 
#' @examples
#' dfr <- data.frame(a=1:4, b=1:4)
#' ss <- dfr[1:2,]
#' refset(rs, dfr[1:2,])
#' dfr$a <- 4:1
#' ss # 1:2
#' rs # 4:3
#' 
#' # same:
#' refset(rs, dfr, 1:2, )
#' 
#' 
#' vec <- 1:10
#' refset(middle, vec[4:6])
#' vec[4:6] <- NA
#' middle 
#' middle <- 4:6 + 100
#' vec
#' 
#' # dynamic versus static indices:
#' dfr <- data.frame(a=rnorm(100), b=rnorm(100))
#' refset(ss, dfr, a>1,)
#' refset(ss.static, dfr, a>1,, dyn.idx=FALSE)
#' nrow(ss) == nrow(ss.static)
#' dfr$a <- dfr$a + 2 * dfr$b
#' 
#' 
#' precious.data <- rnorm(100)
#' refset(big, precious.data, precious.data>1, read.only=TRUE)
#' big
#' \dontrun{
#' big <- big * 2 # throws an error
#' }
#'
#' # Using refset with other functions:
#' # dynamically updated calculated column
#' dfr <- data.frame(a=rnorm(10), b=rnorm(10))
#' refset(rs, transform(dfr, x=a+2*b+rnorm(10)))
#' rs
#' rs # different
#' 
#' # Non-readonly refset with other functions. Works but gives a warning:
#' dontrun{
#' vec <- 1:5
#' refset(ssv, names(vec), read.only=FALSE)
#' ssv <- LETTERS[1:5]
#' vec
#' }
#' 
## the below is not yet true :-( 
## Works nicely with magrittr or dplyr:
# \dontrun{
# a %>% refset(mydata[1:3,1:4])
# }
#
#' @export
refset <- function(x, data, ..., drop=TRUE, dyn.idx=TRUE, read.only=FALSE,
      eval.env=parent.frame(), assign.env=parent.frame()) {
  env <- eval.env
  if (missing(...)) {
    ssarg <- as.character(substitute(data)[[1]])
    dots <- as.list(substitute(data)[-1:-2])
    data <- substitute(data)[[2]]
    if ("drop" %in% names(dots)) {
      drop <- eval(dots$drop, env) # should it be in env? think so
      dots$drop <- NULL
    }
    rdata <- eval(data, env)
  } else {
    ssarg <- "["
    dots <- match.call(expand.dots=FALSE)$...
    rdata <- data
    data <- substitute(data)  
  }
  if (is.name(substitute(x))) x <- deparse(substitute(x))
  assignargs <- list("["="[<-", "[["="[[<-", "$"="$<-")
  assignarg <- assignargs[[ssarg]]
  if (is.null(assignarg)) {
    if (! missing(read.only) && ! read.only) {
      assignarg <- paste0(ssarg, "<-") 
      warning("Using read.only=FALSE with a non-standard argument of ", 
            sQuote(assignarg), ", assigning to ", sQuote(x), 
            " may cause unexpected behaviour.")
    } else {
      read.only <- TRUE
    }
  }
  missings <- sapply(dots, function(x) is.symbol(x) && identical(
        as.character(x), ""))
  if (length(missings)==0) missings <- logical(0)
  # use argument recycling (of TRUE) as a substitute for non-standard eval:
  dots[missings] <- if (dyn.idx) TRUE else lapply(dim(rdata)[missings], seq, 
        from=1)
  isdfr <- is.data.frame(rdata)
  idxval <- if (dyn.idx) {
    eval(substitute(substitute(dots)), env) 
  } else if (isdfr) {
    lapply(dots, eval, envir=eval(data, env), enclos=env)
  } else {
    lapply(dots, eval, envir=env)    
  }
  
  f <- function(v) {
    if (dyn.idx && isdfr && ssarg != "$") idxval <- lapply(idxval, eval, 
          eval(data, env), env) 
    if (missing(v)) {
      args <- c(data, idxval)
      if (length(idxval) > 1) args <- c(args, drop=drop)
      res <- do.call(ssarg, args, envir=env)
      if (! is.null(res)) attr(res, ".refset.") <- TRUE
      res
    } else {
      if (read.only) stop("Tried to assign to a readonly refset")
      do.call("<-", list(data, do.call(assignarg, c(data, idxval, 
        list(value=v)), envir=env)), envir=env)
    }
  }
  
  makeActiveBinding(x, f, assign.env)
}

#' @export
#' @rdname refset
is.refset <- function(x) isTRUE(attr(x, ".refset.")) && 
      bindingIsActive(substitute(x), parent.frame())


#' @export
#' @rdname reference
is.reference <- function(x) isTRUE(attr(x, ".reference.")) && 
      bindingIsActive(substitute(x), parent.frame())


#' Create a reference to an R expression. 
#' 
#' Create a reference to an R expression. Evaluating the reference 
#' evaluates the expression in a prespecified environment.
#'
#' @param x name of the reference to create, as a bare name or a character string
#' @param expr expression to reference
#' @param eval.env environment in which \code{expr} will be evaluated
#' @assign.env environment in which \code{x} will be created
#' 
#' @details
#' This is similar to \code{\link{delayedAssign}}, but allows the expression 
#' \code{expr} to be evaluated repeatedly instead of just once.
#' Assigning to \code{x} gives an error. To create a variable you can assign
#' to, use \code{\link{refset}}.
#' Reassigning to a new variable assigns the result of evaluation, not the 
#' reference. This means that you can't pass references into functions. To do
#' that, use a \code{\link{parcel}}.
#' 
#' @value 
#' \code{reference} returns \code{NULL} invisibly, but binds to \code{x} in
#' \code{assign.env}. \code{is.reference} returns \code{TRUE} or \code{FALSE}.
#' 
#' @examples
#' 
#' reference(rval, sample(1000, 1))
#' rval
#' rval
#' 
#' fixed <- rval
#' fixed
#' fixed
#' 
#' montecarlo <- data.frame(x1=rnorm(10), x2=rnorm(10))
#' reference(dgp, transform(montecarlo, y=2*x1 + 3*x2 + rnorm(nrow(montecarlo))))
#' dgp$y
#' dgp$y
#' replicate(10, coef(lm(y~x1+x2, data=dgp)))
#'  
#' @family parcel
reference <- function(x, expr, eval.env=parent.frame(), 
      assign.env=parent.frame(), quote=TRUE) {
  if (is.name(substitute(x))) x <- deparse(substitute(x))
  if (quote) expr <- substitute(expr)
  
  fn <- function(x) {
    if (! missing(x)) {
      stop("Can't assign to a reference object")
    }
    res <- eval(expr, eval.env)
    if (! is.null(res)) attr(res, ".reference.") <- TRUE
    res
  }
  
  makeActiveBinding(x, fn, assign.env)
}

box <- function(val, env=parent.frame()) {
  stopifnot(is.environment(env))
  box <- new.env(parent=env) # is parent=env necessary?
  # ever a reason to "rebox" a reference with a new environment?
  # and can we do that?
  box$env <- env
  val <- match.call()$val
  #val <- eval(substitute(val), box$env)
  # not working because of ref's NSE. cf Hadley...
  # we need a reference_ function which evaluates val!
  reference(ref, val, eval.env=env, assign.env=box, quote=FALSE)
  class(box) <- c("box", class(box))
  box
}

is.box <- function(x) inherits(x, "box")

unbox <- function(box) {
  stopifnot(is.box(box))
  box$ref
}

unbox_into <- function(x, box, env=parent.frame()) {
  # fix "is reference"
  reference(substitute(x), unbox(box), assign.env=env, quote=FALSE) 
  return()
  if (is.refset(box$ref)) refset(x, unbox(box), env=env) else
  stop("Unknown object in box")
}
