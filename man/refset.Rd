% Generated by roxygen2 (4.0.2): do not edit by hand
\name{refset}
\alias{refset}
\title{Create a reference to a subset of an object}
\usage{
refset(x, data, ..., drop = TRUE, dyn.idx = TRUE, read.only = FALSE,
  env = parent.frame())
}
\arguments{
\item{x}{unquoted name of the refset to create}

\item{data}{the object to refer to}

\item{...}{indices to subset with}

\item{drop}{passed to \code{\link[=Extract]{[}}}

\item{dyn.idx}{update indices dynamically}

\item{read.only}{create a read-only refset which throws an error if assigned
to}

\item{env}{environment in which to create the refset}
}
\value{
Nothing is returned, but the \code{x} argument will be assigned to
  in the calling environment (or in \code{env} if that is specified).
}
\description{
Create a refset - a reference to a subset of an object.
When the object changes, the
contents of the refset change, and when the refset is changed, the object
is changed too.
}
\details{
There are two ways to call \code{refset}. The two-argument form, e.g.
\code{refset(myref, mydata[rows,"mycol"])}, creates a reference to the
subset of \code{mydata} passed in the second argument. The three-or-more
argument form acts like the \code{\link{subset}} function: the indices in
\code{...} are applied to \code{data}. If \code{data} is a data.frame, then
\code{...} is interpreted within it, so you can refer to columns directly:
\code{refset(myref, mydata, a>1 & b<a,)}. Bare column names must be quoted,
however.

Empty arguments in \code{...} are allowed and are treated as indexing
the whole dimension, just as in \code{\link[=Extract]{[}}.

By default, the indices in subset are updated dynamically.
For example, if you call \code{refset(myref, mydata, x >= 3,)} and then
set \code{mydata$x <- 3}, the number of rows in \code{myref} will
increase. To turn this behaviour off and make a reference to a "fixed"
subset of your object, use \code{dyn.idx=FALSE}.
}
\examples{
dfr <- data.frame(a=1:4, b=1:4)
ss <- dfr[1:2,]
refset(rs, dfr[1:2,])
dfr$a <- 4:1
ss # 1:2
rs # 4:3

# same:
refset(rs, dfr, 1:2, )


vec <- 1:10
refset(middle, vec[4:6])
vec[4:6] <- NA
middle
middle <- 4:6 + 100
vec

# dynamic versus static indices:
dfr <- data.frame(a=rnorm(100), b=rnorm(100))
refset(ss, dfr, a>1,)
refset(ss.static, dfr, a>1,, dyn.idx=FALSE)
nrow(ss) == nrow(ss.static)
dfr$a <- dfr$a + 2 * dfr$b


precious.data <- rnorm(100)
refset(big, precious.data, precious.data>1, read.only=TRUE)
big
\dontrun{
big <- big * 2 # throws an error
}
}
\seealso{
Refsets are implemented using \code{makeActiveBinding}
}

